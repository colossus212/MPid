#include "../src/include/Pid.hpp"

// UnitTest++ library
#include "UnitTest++/src/UnitTest++.h"

using namespace Pid;


TEST(ZpZiZdCorrectTest)
{
	PidDbl pidTest;

	double kp = 1.0;
	double ki = 5.0;
	double kd = 6.0;
	double timeStepMs = 1000.0;

	// Set-up controller with P, I and D values
	pidTest.Init(
		kp,									//!< Kp
		ki,									//!< Ki
		kd,									//!< Kd
		Pid::PidDbl::PID_DIRECT,		//!< Control type
		Pid::PidDbl::VELOCITY_PID,		//!< Control type
		timeStepMs,							//!< Update rate (ms)
		0.0,									//!< Min output
		100.0,								//!< Max output
		0.0									//!< Initial set-point
	);
	
	// Now check that Kp, Ki, and Kd were calculated correctly
	
	CHECK_CLOSE(kp, pidTest.GetKp(), 0.0001);
	CHECK_CLOSE(ki, pidTest.GetKi(), 0.0001);
	CHECK_CLOSE(kd, pidTest.GetKd(), 0.0001);

	// Check Zp, Zi, and Zd (time-scaled Ki, Kd, Kp) were calculated correctly
	CHECK_CLOSE(kp, pidTest.GetZp(), 0.0001);
	CHECK_CLOSE(ki/(timeStepMs/1000.0), pidTest.GetZi(), 0.0001);
	CHECK_CLOSE(kd*(timeStepMs/1000.0), pidTest.GetZd(), 0.0001);
}

TEST(ZeroInZeroOutTest)
{
	PidDbl pidTest;

	// Set-up P only controller
	pidTest.Init(
		1.0,									//!< Kp
		0.0,									//!< Ki
		0.0,									//!< Kd
		Pid::PidDbl::PID_DIRECT,		//!< Control type
		Pid::PidDbl::VELOCITY_PID,		//!< Control type
		10.0,									//!< Update rate (ms)
		0.0,									//!< Min output
		100.0,								//!< Max output
		0.0									//!< Initial set-point
	);
	
	pidTest.Run(0.0);

	CHECK_EQUAL(pidTest.output, 0);

}

TEST(POnlyTest)
{
	PidDbl pidTest;

	// Set-up P only controller, non accumulating
	pidTest.Init(
		1.0,									//!< Kp
		0.0,									//!< Ki
		0.0,									//!< Kd
		Pid::PidDbl::PID_DIRECT,		//!< Control type
		Pid::PidDbl::DONT_ACCUMULATE_OUTPUT,		//!< Control type
		1000.0,								//!< Update rate (ms)
		0.0,									//!< Min output
		100.0,								//!< Max output
		0.0									//!< Initial set-point
	);
	
	pidTest.Run(1.0);

	CHECK_CLOSE(1.0, pidTest.output, 0.0001);

}

int main()
{
	return UnitTest::RunAllTests();
}
